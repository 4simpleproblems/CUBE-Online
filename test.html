<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Human Simulator (Redesigned)</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap');
        :root {
            --background-color: #1a1a1a;
            --primary-text-color: #f0f0f0;
            --border-color: #444;
            --surface-color: #2a2a2a;
            --accent-color: #0095ff;
            --accent-hover-color: #0077cc;
            --secondary-color: #888;
            --danger-color: #e74c3c;
            --danger-hover-color: #c0392b;
            --success-color: #2ecc71;
            --success-hover-color: #27ae60;
            --stamina-bar-color: var(--success-color);
            --health-bar-color: var(--danger-color);
            --parry-color: #f1c40f;
        }
        body {
            background-color: var(--background-color);
            color: var(--primary-text-color);
            font-family: 'Poppins', sans-serif;
            margin: 0;
            overflow: hidden;
        }
        #game-viewport {
            background: linear-gradient(to bottom, #232526, #414345);
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
            cursor: default;
        }
        #game-viewport.screenshake { animation: screen-shake 0.3s cubic-bezier(.36,.07,.19,.97) both; }
        #world-container { position: absolute; transition: transform 0.1s linear; }
        .game-object { position: absolute; background-color: #555; border: 1px solid #333; transform-origin: center center; }
        .player-object {
            background-color: transparent;
            border: none;
            transition: opacity 0.3s ease;
            z-index: 10;
            transform-style: preserve-3d;
        }
        .player-object.stunned .player-sprite-wrapper { animation: flicker 0.1s linear infinite; }
        .player-object .charge-indicator {
            position: absolute;
            bottom: -15px;
            left: 50%;
            width: 0;
            height: 8px;
            background: linear-gradient(90deg, #fff, #f1c40f, #e67e22, var(--danger-color));
            border: 1px solid rgba(0,0,0,0.5);
            border-radius: 4px;
            transform: translateX(-50%);
            transition: width 0.1s linear, box-shadow 0.2s;
            opacity: 0;
        }
        .player-object.charging .charge-indicator { opacity: 1; }
        .player-object .charge-indicator.precision { box-shadow: 0 0 15px 5px #fff; }

        @keyframes screen-shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        @keyframes flicker { 50% { opacity: 0.3; } }
        .player-sprite-wrapper { width: 100%; height: 100%; position: relative; transform-style: preserve-3d; transition: transform 0.2s; }
        .player-sprite { width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated; position: absolute; backface-visibility: hidden; }
        .player-sprite.front { transform: rotateY(0deg); }
        .player-sprite.back { transform: rotateY(180deg) scaleX(-1); }
        .player-status-container { position: absolute; top: -35px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; gap: 4px; width: 60px; }
        .player-name { font-size: 12px; color: #fff; text-shadow: 1px 1px 2px black; white-space: nowrap; font-weight: bold; }
        .player-health-bar-container { width: 100%; height: 6px; background-color: rgba(0,0,0,0.5); border-radius: 3px; border: 1px solid rgba(0,0,0,0.7); overflow: hidden; }
        .player-health-bar { width: 100%; height: 100%; background-color: var(--health-bar-color); transition: width 0.2s linear; }
        .hidden { display: none !important; }
        .ui-view { display: flex; align-items: center; justify-content: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 30; padding: 20px; box-sizing: border-box; background: rgba(0,0,0,0.5); backdrop-filter: blur(10px); }
        #menu-container { display: flex; flex-direction: column; gap: 20px; background: var(--surface-color); padding: 25px; border-radius: 16px; box-shadow: 0 8px 30px rgba(0,0,0,0.2); width: 100%; max-width: 420px; text-align: center; border: 1px solid var(--border-color); }
        #menu-container h1 { font-size: 2.2rem; margin: 0 0 10px 0; color: var(--primary-text-color); }
        .menu-input { width: 100%; padding: 14px; font-family: 'Poppins', sans-serif; font-size: 1rem; border: 2px solid var(--border-color); border-radius: 10px; box-sizing: border-box; text-align: center; transition: border-color 0.2s, box-shadow 0.2s; background: #333; color: #fff; }
        .menu-input:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent-color) 25%, transparent); }
        .join-actions { display: flex; flex-direction: column; gap: 15px; }
        .menu-button { width: 100%; padding: 14px 28px; font-family: 'Poppins', sans-serif; font-weight: bold; font-size: 1.1rem; border: none; border-radius: 10px; cursor: pointer; transition: background-color 0.2s, transform 0.1s; }
        .menu-button:active { transform: scale(0.98); }
        #join-lobby-btn-new { background-color: var(--accent-color); color: white; }
        #join-lobby-btn-new:hover { background-color: var(--accent-hover-color); }
        .create-lobby-actions { margin-top: 10px; font-size: 0.9rem; color: var(--secondary-color); }
        #create-lobby-btn-new { background: none; border: none; color: var(--accent-color); font-family: 'Poppins', sans-serif; font-weight: bold; cursor: pointer; text-decoration: underline; padding: 5px; font-size: 0.9rem; }
        #create-lobby-btn-new:hover { color: var(--accent-hover-color); }
        @media (min-width: 500px) { .join-actions { flex-direction: row; gap: 10px; } #lobby-code-input-new { flex-grow: 3; } #join-lobby-btn-new { flex-grow: 2; } }
        .btn { padding: 12px 24px; font-family: 'Poppins', sans-serif; font-weight: bold; border: none; background-color: var(--accent-color); color: white; cursor: pointer; border-radius: 6px; margin: 5px; font-size: 1rem; transition: background-color 0.2s, transform 0.1s; }
        .btn:hover { background-color: var(--accent-hover-color); }
        .btn:active { transform: scale(0.98); }
        .btn-danger { background-color: var(--danger-color); }
        .btn-danger:hover { background-color: var(--danger-hover-color); }
        #game-ui { position: absolute; top: 15px; left: 15px; z-index: 25; display: flex; flex-direction: column; gap: 10px; }
        .status-bar-container { width: 200px; height: 12px; background-color: rgba(0,0,0,0.5); border-radius: 6px; border: 1px solid #000; overflow: hidden; margin-top: 5px; }
        #health-bar, #stamina-bar { width: 100%; height: 100%; border-radius: 5px; transition: width 0.2s linear; }
        #health-bar { background-color: var(--health-bar-color); }
        #stamina-bar { background-color: var(--stamina-bar-color); }
        #host-info { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); padding: 8px 12px; background: rgba(0,0,0,0.7); color: var(--primary-text-color); border-radius: 6px; }
        .loader { border: 4px solid var(--border-color); border-top: 4px solid var(--accent-color); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        #message-box { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 40; opacity: 0; pointer-events: none; transition: opacity 0.2s ease-in-out; }
        #message-box.visible { opacity: 1; pointer-events: auto; }
        #message-box-content { background-color: var(--surface-color); color: var(--primary-text-color); padding: 20px 25px; border-radius: 12px; text-align: center; box-shadow: 0 8px 30px rgba(0,0,0,0.2); max-width: 90%; width: 400px; animation: modal-fade-in 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        #message-title { font-size: 1.5rem; font-weight: 700; margin: 0 0 10px 0; }
        #message-text { font-size: 1rem; color: var(--secondary-color); line-height: 1.5; margin: 0; }
        #message-box-ok { margin-top: 25px; padding: 10px 30px; }
        #mobile-controls { position: fixed; bottom: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 25; }
        .mobile-control-zone { position: absolute; bottom: 20px; pointer-events: auto; }
        #joystick-zone { left: 20px; width: 150px; height: 150px; background: rgba(0,0,0,0.2); border-radius: 50%; }
        #joystick-nub { position: absolute; width: 60px; height: 60px; background: rgba(255,255,255,0.2); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); transition: transform 0.1s; border: 2px solid rgba(255,255,255,0.3); }
        #action-buttons-zone { right: 20px; display: flex; gap: 20px; align-items: flex-end; }
        .mobile-action-btn { width: 65px; height: 65px; background: rgba(0,0,0,0.3); border: 2px solid rgba(0,0,0,0.5); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.8rem; color: white; user-select: none; }
        .mobile-action-btn:active { background: rgba(0,0,0,0.5); }
        #mobile-parry-btn { background-color: color-mix(in srgb, var(--parry-color) 70%, #000); }
        #mobile-attack-btn { background-color: color-mix(in srgb, var(--danger-color) 70%, #000); }
    </style>
</head>
<body>
    <div id="game-viewport">
        <div id="world-container"></div>
        <div id="off-screen-indicators"></div>
        <div id="game-ui" class="hidden">
            <div id="health-bar-container" class="status-bar-container"><div id="health-bar"></div></div>
            <div id="stamina-bar-container" class="status-bar-container"><div id="stamina-bar"></div></div>
            <button id="leave-lobby-btn" class="btn btn-danger">Leave</button>
        </div>
        <div id="mobile-controls" class="hidden">
            <div id="joystick-zone" class="mobile-control-zone"><div id="joystick-nub"></div></div>
            <div id="action-buttons-zone" class="mobile-control-zone">
                <div id="mobile-parry-btn" class="mobile-action-btn">PARRY</div>
                <div id="mobile-attack-btn" class="mobile-action-btn">ATTACK</div>
                <div id="mobile-jump-btn" class="mobile-action-btn">JUMP</div>
            </div>
        </div>
        <div id="menu-view" class="ui-view">
             <div id="menu-container">
                <h1>Human Simulator</h1>
                <input type="text" id="username-new" class="menu-input" placeholder="Enter Your Username">
                <div class="join-actions">
                    <input type="text" id="lobby-code-input-new" class="menu-input" placeholder="Enter Lobby Code">
                    <button id="join-lobby-btn-new" class="menu-button">Join Lobby</button>
                </div>
                <div class="create-lobby-actions">or <button id="create-lobby-btn-new">Create a New Lobby</button></div>
            </div>
        </div>
        <div id="loading-view" class="ui-view hidden">
            <div id="menu-container">
                <h1 id="loading-title">Creating Lobby...</h1>
                <p id="loading-code-display" style="font-size: 1.5rem; margin-bottom: 25px;"></p>
                <div class="loader" style="margin: 0 auto;"></div>
                <p id="loading-status" style="margin-top: 25px;">Connecting...</p>
            </div>
        </div>
    </div>
    <div id="host-info" class="hidden">Lobby Code: <span id="lobby-code-display"></span></div>
    <div id="message-box" class="hidden"><div id="message-box-content"><h2 id="message-title"></h2><p id="message-text"></p><button id="message-box-ok" class="btn">OK</button></div></div>

    <script>
        // --- Matter.js Aliases ---
        const { Engine, Runner, World, Bodies, Body, Events, Vector } = Matter;

        // --- Game Configuration ---
        const CONFIG = {
            WORLD_WIDTH: 100000,
            WORLD_HEIGHT: 10000,
            SPRINT_PARTICLE_INTERVAL: 100,
            LOBBY_PREFIX: 'HUMAN-SIM-V2-',
            SESSION_KEY: 'humanSimulatorSessionV2',
            COMBAT: {
                STAMINA_REGEN_RATE: 20,
                STAMINA_DRAIN_RATE: 30,
                CHARGE_STAMINA_COST: 5,
                ATTACK_STAMINA_COST: 15,
                PARRY_STAMINA_COST: 20,
                PARRY_WINDOW_MS: 150,
                PARRY_COOLDOWN_MS: 1000,
                CHARGE_DURATION_MS: 1200,
                PRECISION_STRIKE_WINDOW_MS: 100,
                BASE_DAMAGE: 8,
                PRECISION_STRIKE_BONUS: 12,
                COUNTER_ATTACK_DAMAGE: 20,
                ATTACK_RANGE: 75,
                KNOCKBACK_FORCE: 8,
                PRECISION_KNOCKBACK_FORCE: 16,
                COUNTER_ATTACK_WINDOW_MS: 400,
                STUN_DURATION_MS: 500,
            }
        };

        /**
         * Simple Event Emitter
         */
        class EventEmitter {
            constructor() { this.events = {}; }
            on(eventName, listener) {
                if (!this.events[eventName]) this.events[eventName] = [];
                this.events[eventName].push(listener);
            }
            emit(eventName, ...args) {
                if (this.events[eventName]) {
                    this.events[eventName].forEach(listener => listener(...args));
                }
            }
        }

        /**
         * Manages all UI interactions and DOM element manipulation.
         */
        class UIManager {
            constructor() {
                this.elements = {
                    gameViewport: document.getElementById('game-viewport'),
                    worldContainer: document.getElementById('world-container'),
                    gameUI: document.getElementById('game-ui'),
                    mobileControls: document.getElementById('mobile-controls'),
                    menuView: document.getElementById('menu-view'),
                    loadingView: document.getElementById('loading-view'),
                    healthBar: document.getElementById('health-bar'),
                    staminaBar: document.getElementById('stamina-bar'),
                    hostInfo: document.getElementById('host-info'),
                    lobbyCodeDisplay: document.getElementById('lobby-code-display'),
                    messageBox: document.getElementById('message-box'),
                    messageTitle: document.getElementById('message-title'),
                    messageText: document.getElementById('message-text'),
                    messageOk: document.getElementById('message-box-ok'),
                };
            }
            
            showView(viewName) {
                ['menuView', 'loadingView', 'gameUI'].forEach(v => {
                    const el = this.elements[v.replace('UI','gameUI')]; // Small hack for gameUI
                    if (el) el.classList.toggle('hidden', v !== viewName);
                });
                if(viewName === 'gameUI') this.elements.mobileControls.classList.remove('hidden');
            }

            updatePlayerStatus(player) {
                this.elements.healthBar.style.width = `${(player.health / player.maxHealth) * 100}%`;
                this.elements.staminaBar.style.width = `${(player.stamina / player.maxStamina) * 100}%`;
            }

            setHostInfo(code) {
                this.elements.lobbyCodeDisplay.textContent = code;
                this.elements.hostInfo.classList.remove('hidden');
            }

            showMessage(title, text, onOk, options = {}) {
                this.elements.messageTitle.textContent = title;
                this.elements.messageText.textContent = text;
                this.elements.messageBox.classList.remove('hidden');
                setTimeout(() => this.elements.messageBox.classList.add('visible'), 10);
                
                const newOkButton = this.elements.messageOk.cloneNode(true);
                this.elements.messageOk.parentNode.replaceChild(newOkButton, this.elements.messageOk);
                this.elements.messageOk = newOkButton;

                const closeAndCallback = () => {
                    this.elements.messageBox.classList.remove('visible');
                    setTimeout(() => this.elements.messageBox.classList.add('hidden'), 200);
                    if (onOk) onOk();
                };
                newOkButton.addEventListener('click', closeAndCallback, { once: true });
            }
            
            triggerScreenShake() {
                this.elements.gameViewport.classList.remove('screenshake');
                void this.elements.gameViewport.offsetWidth; // Trigger reflow
                this.elements.gameViewport.classList.add('screenshake');
            }

            updateCamera(camera, playerPosition) {
                const viewportWidth = this.elements.gameViewport.clientWidth;
                const viewportHeight = this.elements.gameViewport.clientHeight;
                const targetX = -playerPosition.x * camera.scale + viewportWidth / 2;
                const targetY = -playerPosition.y * camera.scale + viewportHeight / 2;
                this.elements.worldContainer.style.transform = `translate(${targetX}px, ${targetY}px) scale(${camera.scale})`;
            }
        }

        /**
         * Manages all user input, for both desktop and mobile.
         */
        class InputManager {
            constructor(game) {
                this.game = game;
                this.keys = {};
                this.isMobile = 'ontouchstart' in window;
                this.setupControls();
            }

            setupControls() {
                if (this.isMobile) {
                    this.setupMobileControls();
                } else {
                    this.setupDesktopControls();
                }
            }
            
            setupDesktopControls() {
                document.addEventListener('keydown', e => {
                    if (!this.keys[e.code]) this.game.events.emit('input:keydown', e.code);
                    this.keys[e.code] = true;
                });
                document.addEventListener('keyup', e => {
                    this.keys[e.code] = false;
                     this.game.events.emit('input:keyup', e.code);
                });
                document.addEventListener('mousedown', e => {
                    if (e.button === 0) this.game.events.emit('input:attack_down');
                });
                document.addEventListener('mouseup', e => {
                    if (e.button === 0) this.game.events.emit('input:attack_up');
                });
            }

            setupMobileControls() {
                // Simplified for brevity - this would contain the joystick and button logic
                document.getElementById('mobile-jump-btn').addEventListener('touchstart', e => { e.preventDefault(); this.game.events.emit('input:keydown', 'Space'); });
                document.getElementById('mobile-attack-btn').addEventListener('touchstart', e => { e.preventDefault(); this.game.events.emit('input:attack_down'); });
                document.getElementById('mobile-attack-btn').addEventListener('touchend', e => { e.preventDefault(); this.game.events.emit('input:attack_up'); });
                document.getElementById('mobile-parry-btn').addEventListener('touchstart', e => { e.preventDefault(); this.game.events.emit('input:keydown', 'KeyC'); });
                // Joystick logic would update this.keys['KeyA'] etc.
            }
        }

        /**
         * Represents a player entity in the game.
         */
        class Player {
            constructor(id, username, position, isNpc = false, color = null) {
                this.id = id;
                this.username = username;
                this.isNpc = isNpc;
                this.element = this.createElement();
                this.body = this.createBody(position);
                this.direction = 'right';
                this.onGround = false;
                this.isSprinting = false;
                this.lastMoveTimestamp = Date.now();
                this.color = color || this.generateDarkColor();

                // Stats
                this.maxHealth = 100;
                this.health = 100;
                this.maxStamina = 100;
                this.stamina = 100;

                // Combat State
                this.isCharging = false;
                this.chargeStartTime = 0;
                this.isParrying = false;
                this.lastParryTime = 0;
                this.isStunned = false;
                this.canCounter = false;
                
                this.update(this, true); // initial draw
            }
            
            createElement() {
                const el = document.createElement('div');
                el.id = `player-${this.id}`;
                el.className = 'player-object';
                el.innerHTML = `
                    <div class="player-sprite-wrapper">
                        <img src="./images/player-idle1.png" class="player-sprite front" alt="Player">
                        <img src="./images/player-idle1.png" class="player-sprite back" alt="Player">
                    </div>
                    <div class="player-status-container">
                         <div class="player-health-bar-container"><div id="player-health-${this.id}" class="player-health-bar"></div></div>
                         <div class="player-name">${this.isNpc ? `[NPC] ` : ''}${this.username}</div>
                    </div>
                    <div class="charge-indicator"></div>`;
                document.getElementById('world-container').appendChild(el);
                return el;
            }
            
            createBody(position) {
                return Bodies.rectangle(position.x, position.y, 40, 60, {
                    inertia: Infinity, frictionAir: 0.02, friction: 0.1, label: `player_${this.id}`
                });
            }
            
            update(state, isLocal) {
                if (!isLocal) {
                    // Interpolate or snap position for remote players
                    Body.setPosition(this.body, state.position);
                    Body.setVelocity(this.body, state.velocity);
                    this.health = state.health;
                    this.isStunned = state.isStunned;
                    this.isCharging = state.isCharging;
                }
                
                this.direction = state.direction;
                
                // DOM updates
                const { position, angle } = this.body;
                this.element.style.transform = `translate(${position.x - 20}px, ${position.y - 30}px) rotate(${angle}rad)`;
                this.element.querySelector('.player-sprite-wrapper').style.transform = `rotateY(${this.direction === 'left' ? 180 : 0}deg)`;
                this.element.classList.toggle('stunned', this.isStunned);
                this.element.classList.toggle('charging', this.isCharging);
                
                // Health bar
                const healthBar = document.getElementById(`player-health-${this.id}`);
                if(healthBar) healthBar.style.width = `${(this.health / this.maxHealth) * 100}%`;
                
                // Charge indicator
                if (this.isCharging) {
                    const chargeIndicator = this.element.querySelector('.charge-indicator');
                    const chargePercent = Math.min(1, (Date.now() - this.chargeStartTime) / CONFIG.COMBAT.CHARGE_DURATION_MS);
                    chargeIndicator.style.width = `${chargePercent * 100}%`;
                    const isPrecision = Math.abs((Date.now() - this.chargeStartTime) - CONFIG.COMBAT.CHARGE_DURATION_MS) < CONFIG.COMBAT.PRECISION_STRIKE_WINDOW_MS;
                    chargeIndicator.classList.toggle('precision', isPrecision);
                }
            }
            
            destroy() {
                this.element.remove();
                // World.remove will be handled by Game class
            }
            
            generateDarkColor() { /* ... as before ... */ return `hsl(${Math.floor(Math.random() * 361)}, ${70 + Math.floor(Math.random() * 31)}%, ${35 + Math.floor(Math.random() * 16)}%)`; }
        }

        /**
         * Main game class to orchestrate all other components.
         */
        class Game {
            constructor() {
                this.ui = new UIManager();
                this.events = new EventEmitter();
                this.input = new InputManager(this);
                this.network = new NetworkManager(this);

                this.players = new Map();
                this.myId = null;
                this.isHost = false;
                this.lastTime = performance.now();
                this.camera = { x: 0, y: 0, scale: 1 };
                
                this.setupEngine();
                this.bindEvents();
                this.ui.showView('menuView');
            }

            setupEngine() {
                this.engine = Engine.create({ gravity: { y: 1 } });
                this.world = this.engine.world;
                this.runner = Runner.create();
                Events.on(this.engine, 'afterUpdate', () => this.gameLoop());
                Events.on(this.engine, 'collisionStart', (event) => this.handleCollisions(event));
            }

            bindEvents() {
                // UI Events
                document.getElementById('create-lobby-btn-new').addEventListener('click', () => this.network.startLobby(true));
                document.getElementById('join-lobby-btn-new').addEventListener('click', () => this.network.startLobby(false));
                
                // Network Events
                this.events.on('network:ready', ({id, isHost}) => {
                    this.myId = id;
                    this.isHost = isHost;
                    if(isHost) this.ui.setHostInfo(this.network.lobbyCode);
                    this.startGame();
                });
                this.events.on('network:new_player', (playerInfo) => this.addPlayer(playerInfo));
                this.events.on('network:player_left', (id) => this.removePlayer(id));
                this.events.on('network:state_update', (states) => this.updateGameState(states));
                this.events.on('network:show_message', (title, text) => this.ui.showMessage(title, text));
                this.events.on('network:effect', (effect) => this.handleEffect(effect));


                // Input Events
                this.events.on('input:keydown', (key) => this.handleKeyDown(key));
                this.events.on('input:attack_down', () => this.localPlayerAction('attack_down'));
                this.events.on('input:attack_up', () => this.localPlayerAction('attack_up'));
            }

            startGame() {
                this.createWorld();
                const localPlayerInfo = {
                    id: this.myId,
                    username: this.network.username,
                    position: { x: CONFIG.WORLD_WIDTH / 2, y: CONFIG.WORLD_HEIGHT - 200 }
                };
                this.addPlayer(localPlayerInfo, true);
                
                Runner.run(this.runner, this.engine);
                this.ui.showView('gameUI');
            }
            
            gameLoop() {
                const now = performance.now();
                const deltaTime = now - this.lastTime;
                this.lastTime = now;

                const me = this.players.get(this.myId);
                if (!me) return;
                
                this.processLocalInput(me, deltaTime);
                
                // Update all players
                this.players.forEach(p => p.update(p, p.id === this.myId));

                // Host is authoritative
                if (this.isHost) {
                    this.network.broadcastState(this.getSimplifiedState());
                } else {
                    this.network.sendStateToHost(me);
                }
                
                this.ui.updatePlayerStatus(me);
                this.ui.updateCamera(this.camera, me.body.position);
            }
            
            addPlayer(playerInfo, isLocal = false) {
                if (this.players.has(playerInfo.id)) return;
                const player = new Player(playerInfo.id, playerInfo.username, playerInfo.position);
                this.players.set(player.id, player);
                World.add(this.world, player.body);
                if(isLocal) this.myId = player.id;
            }
            
            removePlayer(id) {
                if (!this.players.has(id)) return;
                const player = this.players.get(id);
                World.remove(this.world, player.body);
                player.destroy();
                this.players.delete(id);
            }

            getSimplifiedState() {
                const state = {};
                this.players.forEach(p => {
                    state[p.id] = { 
                        position: p.body.position, 
                        velocity: p.body.velocity,
                        direction: p.direction,
                        health: p.health,
                        isStunned: p.isStunned,
                        isCharging: p.isCharging
                    };
                });
                return state;
            }
            
            updateGameState(states) {
                if(this.isHost) return;
                for (const id in states) {
                    if (id !== this.myId && this.players.has(id)) {
                        this.players.get(id).update(states[id], false);
                    }
                }
            }

            handleKeyDown(key) {
                const me = this.players.get(this.myId);
                if (!me) return;
                if (key === 'Space' && me.onGround && !me.isCharging) {
                     Body.setVelocity(me.body, { x: me.body.velocity.x, y: -16 });
                     me.onGround = false;
                }
                if (key === 'KeyC') {
                    this.localPlayerAction('parry');
                }
            }
            
            localPlayerAction(type) {
                const me = this.players.get(this.myId);
                if(!me || me.isStunned) return;

                switch (type) {
                    case 'attack_down':
                        if (me.canCounter) {
                           this.network.sendAction({ type: 'counter' });
                           me.canCounter = false;
                           return;
                        }
                        if (me.stamina >= CONFIG.COMBAT.CHARGE_STAMINA_COST && !me.isCharging) {
                            me.isCharging = true;
                            me.chargeStartTime = Date.now();
                            me.stamina -= CONFIG.COMBAT.CHARGE_STAMINA_COST;
                        }
                        break;
                    case 'attack_up':
                        if (me.isCharging) {
                            const chargeDuration = Date.now() - me.chargeStartTime;
                            me.isCharging = false;
                            if (me.stamina >= CONFIG.COMBAT.ATTACK_STAMINA_COST) {
                                me.stamina -= CONFIG.COMBAT.ATTACK_STAMINA_COST;
                                const isPrecision = Math.abs(chargeDuration - CONFIG.COMBAT.CHARGE_DURATION_MS) < CONFIG.COMBAT.PRECISION_STRIKE_WINDOW_MS;
                                this.network.sendAction({ type: 'attack', isPrecision, direction: me.direction });
                            }
                        }
                        break;
                    case 'parry':
                         if (Date.now() - me.lastParryTime > CONFIG.COMBAT.PARRY_COOLDOWN_MS && me.stamina >= CONFIG.COMBAT.PARRY_STAMINA_COST) {
                            me.stamina -= CONFIG.COMBAT.PARRY_STAMINA_COST;
                            me.lastParryTime = Date.now();
                            me.isParrying = true;
                            setTimeout(() => me.isParrying = false, CONFIG.COMBAT.PARRY_WINDOW_MS);
                            this.network.sendAction({ type: 'parry' });
                        }
                        break;
                }
            }
            
            handleEffect({type, payload}) {
                if (type === 'hit') {
                    if (payload.targetId === this.myId) {
                        this.ui.triggerScreenShake();
                    }
                }
                if (type === 'parry_success') {
                    if (payload.parrierId === this.myId) {
                        this.ui.showMessage("Parried!", "Counter now!", null, { duration: CONFIG.COMBAT.COUNTER_ATTACK_WINDOW_MS });
                    }
                }
            }

            processLocalInput(player, deltaTime) {
                if(player.isStunned || player.isCharging) return;
                
                player.stamina = Math.min(player.maxStamina, player.stamina + CONFIG.COMBAT.STAMINA_REGEN_RATE * (deltaTime / 1000));
                
                const moveSpeed = 5;
                if (this.input.keys['KeyA'] || this.input.keys['ArrowLeft']) {
                    Body.setVelocity(player.body, { x: -moveSpeed, y: player.body.velocity.y });
                    player.direction = 'left';
                } else if (this.input.keys['KeyD'] || this.input.keys['ArrowRight']) {
                    Body.setVelocity(player.body, { x: moveSpeed, y: player.body.velocity.y });
                    player.direction = 'right';
                } else if(player.onGround) {
                    Body.setVelocity(player.body, { x: 0, y: player.body.velocity.y });
                }
            }
            
            handleCollisions(event) {
                event.pairs.forEach(pair => {
                    const labels = [pair.bodyA.label, pair.bodyB.label];
                    const playerLabel = labels.find(l => l.startsWith('player_'));
                    if (playerLabel && (labels.includes('ground'))) {
                        const playerId = playerLabel.split('_')[1];
                        if (this.players.has(playerId)) {
                            this.players.get(playerId).onGround = true;
                        }
                    }
                });
            }
            
            createWorld() {
                const ground = Bodies.rectangle(CONFIG.WORLD_WIDTH / 2, CONFIG.WORLD_HEIGHT, CONFIG.WORLD_WIDTH, 20, { isStatic: true, label: 'ground' });
                World.add(this.world, [ground]);
            }
        }
        
        /**
         * Manages all networking via PeerJS.
         */
        class NetworkManager {
            constructor(game) {
                this.game = game;
                this.peer = null;
                this.myId = null;
                this.isHost = false;
                this.connections = new Map();
                this.username = '';
                this.lobbyCode = '';
            }
            
            startLobby(isCreating) {
                this.username = document.getElementById('username-new').value.trim();
                if(!this.username) return this.game.ui.showMessage('Error', 'Please enter a username.');
                
                this.isHost = isCreating;
                this.lobbyCode = isCreating ? this.generateLobbyCode() : document.getElementById('lobby-code-input-new').value.trim().toUpperCase();
                
                document.getElementById('loading-title').textContent = isCreating ? 'Creating Lobby...' : 'Joining Lobby...';
                document.getElementById('loading-code-display').textContent = this.lobbyCode;
                this.game.ui.showView('loadingView');

                this.initializePeer();
            }

            initializePeer() {
                if (this.peer) this.peer.destroy();
                const peerId = this.isHost ? CONFIG.LOBBY_PREFIX + this.lobbyCode : null;
                this.peer = new Peer(peerId, { /* ICE servers config */ });
                this.peer.on('open', id => {
                    this.myId = id;
                    if (this.isHost) {
                        this.game.events.emit('network:ready', {id: this.myId, isHost: true});
                    } else {
                        this.connectToHost();
                    }
                });
                this.peer.on('connection', conn => this.setupConnection(conn));
                this.peer.on('error', err => this.game.ui.showMessage('Connection Error', `Failed to connect: ${err.type}`));
            }
            
            connectToHost() {
                const hostId = CONFIG.LOBBY_PREFIX + this.lobbyCode;
                const conn = this.peer.connect(hostId, { metadata: { username: this.username }, reliable: true });
                this.setupConnection(conn, true);
            }
            
            setupConnection(conn, isClient = false) {
                conn.on('open', () => {
                    this.connections.set(conn.peer, conn);
                    if(isClient) { // This is our connection to the host
                        this.game.events.emit('network:ready', {id: this.myId, isHost: false});
                    }
                    if(this.isHost) {
                        // Welcome new player
                        const newPlayerInfo = { id: conn.peer, username: conn.metadata.username, position: { x: CONFIG.WORLD_WIDTH / 2, y: CONFIG.WORLD_HEIGHT - 200 }};
                        this.game.addPlayer(newPlayerInfo);
                        
                        // Send existing players to the new player
                        const allPlayers = Array.from(this.game.players.values()).map(p => ({id: p.id, username: p.username, position: p.body.position}));
                        conn.send({type: 'welcome', players: allPlayers});
                        
                        // Tell everyone else about the new player
                        this.broadcast({type: 'new_player', playerInfo: newPlayerInfo}, conn.peer);
                    }
                });
                conn.on('data', data => this.handleData(conn.peer, data));
                conn.on('close', () => {
                    this.connections.delete(conn.peer);
                    this.game.events.emit('network:player_left', conn.peer);
                });
            }
            
            handleData(peerId, data) {
                switch(data.type) {
                    case 'welcome':
                        data.players.forEach(p => this.game.events.emit('network:new_player', p));
                        break;
                    case 'new_player':
                        this.game.events.emit('network:new_player', data.playerInfo);
                        break;
                    case 'state_update': // From host to clients
                        this.game.events.emit('network:state_update', data.state);
                        break;
                    case 'client_state': // From client to host
                        if(this.isHost) {
                           const player = this.game.players.get(peerId);
                           if(player) player.update(data.state, false);
                        }
                        break;
                    case 'action': // From client to host
                        if(this.isHost) this.processPlayerAction(peerId, data.action);
                        break;
                    case 'effect': // From host to clients
                        this.game.events.emit('network:effect', data);
                        break;
                }
            }

            processPlayerAction(playerId, action) {
                const player = this.game.players.get(playerId);
                if (!player) return;
                
                switch(action.type) {
                    case 'attack':
                        // Host validates the attack and determines hits
                        const C = CONFIG.COMBAT;
                        const targets = Array.from(this.game.players.values()).filter(p => p.id !== playerId);
                        targets.forEach(target => {
                            if (Vector.magnitude(Vector.sub(player.body.position, target.body.position)) < C.ATTACK_RANGE) {
                                if (target.isParrying) {
                                    player.isStunned = true;
                                    target.canCounter = true;
                                    setTimeout(() => player.isStunned = false, C.STUN_DURATION_MS);
                                    setTimeout(() => target.canCounter = false, C.COUNTER_ATTACK_WINDOW_MS);
                                    this.broadcast({type: 'effect', payload: {parrierId: target.id, attackerId: player.id}, effectType: 'parry_success'});

                                } else {
                                    let damage = action.isPrecision ? C.BASE_DAMAGE + C.PRECISION_STRIKE_BONUS : C.BASE_DAMAGE;
                                    target.health -= damage;
                                    this.broadcast({type: 'effect', payload: {targetId: target.id, damage}, effectType: 'hit'});
                                }
                            }
                        });
                        break;
                    case 'parry':
                        player.isParrying = true;
                        setTimeout(() => player.isParrying = false, CONFIG.COMBAT.PARRY_WINDOW_MS);
                        break;
                    case 'counter':
                        if (player.canCounter) {
                            // process counter logic
                        }
                        break;
                }
            }
            
            broadcast(data, excludeId = null) {
                this.connections.forEach((conn, id) => {
                    if (id !== excludeId) conn.send(data);
                });
            }
            
            broadcastState(state) {
                this.broadcast({ type: 'state_update', state });
            }
            
            sendStateToHost(localPlayer) {
                const hostConn = this.connections.values().next().value;
                if (hostConn) {
                    hostConn.send({
                        type: 'client_state',
                        state: {
                            position: localPlayer.body.position,
                            velocity: localPlayer.body.velocity,
                            direction: localPlayer.direction
                        }
                    });
                }
            }

            sendAction(action) {
                 if (this.isHost) {
                    this.processPlayerAction(this.myId, action);
                 } else {
                    const hostConn = this.connections.values().next().value;
                    if(hostConn) hostConn.send({type: 'action', action});
                 }
            }
            
            generateLobbyCode() { return Math.random().toString(36).substring(2, 10).toUpperCase(); }
        }

        // --- Game Entry Point ---
        document.addEventListener('DOMContentLoaded', () => {
            new Game();
        });

    </script>
</body>
</html>
